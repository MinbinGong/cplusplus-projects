/*
 * 1243. Array Transformation
 * 
 * Given an initial array arr, every day you produce a new array using the array of the previous day.
 * 
 * On the i-th day, you do the following operations on the array of day i-1 to produce the array of day i:
 * 
 * If an element is smaller than both its left neighbor and its right neighbor, then this element is incremented.
 * If an element is bigger than both its left neighbor and its right neighbor, then this element is decremented.
 * The first and last elements never change.
 * 
 * After some days, the array does not change. Return that final array.
 *
 * 
 * Example 1:
 * Input: arr = [6,2,3,4]
 * Output: [6,3,3,4]
 * Explanation: 
 * On the first day, the array is changed from [6,2,3,4] to [6,3,3,4].
 * Neither 2 nor 4 can be changed because they are already the minimum or maximum values in the array.
 * On the second day, the array is changed from [6,3,3,4] to [6,4,4,4].
 * 4 is already the minimum value in the array, so it is not changed.
 * On the third day, the array is changed from [6,4,4,4] to [6,4,4,4].
 * So the array does not change after the third day.
 * 
 * Example 2:
 * Input: arr = [1,6,3,4,3,5]
 * Output: [1,4,4,4,4,5]
 * Explanation: 
 * On the first day, the array is changed from [1,6,3,4,3,5] to [1,5,4,3,4,5].
 * On the second day, the array is changed from [1,5,4,3,4,5] to [1,4,4,4,4,5].
 * On the third day, the array is changed from [1,4,4,4,4,5] to [1,4,4,4,4,5].
 * So the array does not change after the third day.
 * 
 * Note:
 * 1 <= arr.length <= 100
 * 1 <= arr[i] <= 100
 * 
 */
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> transformArray(vector<int>& arr) {
        bool changed;                     // flag to track if any change occurred
        do {
            changed = false;
            vector<int> next = arr;        // copy current state
            int n = arr.size();
            // first and last elements never change
            for (int i = 1; i < n - 1; ++i) {
                if (arr[i] < arr[i-1] && arr[i] < arr[i+1]) {
                    next[i]++;             // increase local minimum
                    changed = true;
                } else if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
                    next[i]--;             // decrease local maximum
                    changed = true;
                }
            }
            arr = next;                     // update array for next iteration
        } while (changed);                  // repeat until stable

        return arr;
    }
};